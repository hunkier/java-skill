# JVM

**（1）基本概念**

​	JVM是可运行Java代码的假想计算器，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域。JVM是运行在操作系统之上，它与硬件没有直接的交互。

![JVM](./assets/jvm/JVM.png)



(2)运行过程

​	我们都知道Java源文件，通过编译器，能够产生相应的.class文件，也就是字节码文件，而字节码文件有通过Java虚拟机中的解释器，编译成特定机器上的机器码。

也就是如下：

​	①Java源文件—>编译器—>字节码文件

​	②字节码文件—>JVM—>机器码

​	每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也是Java为什么能够跨平台的原因，当一个程序从开始运行，这是虚拟机就凯斯实例化了，多个程序启动就会存在多个虚拟机示例。程序退出或者关闭，则虚拟机示例消亡，多个虚拟机示例之间数据不能共享。

![JVM](./assets/jvm/Java-Runtime.png)



## 2.1.线程

​	这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot  JVM 中的 Java 线程与原生操作系统的线程有直接的映射关系。当本地线程存储、缓存区分配、同步对象、栈、程序计数器等准备好后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度Java线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。

​	Hotspot JVM 后台运行的系统线程主要有下面几个：

| 虚拟机线程            (VM thread) | 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程中里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有： stop-the-world 垃圾回收、线程 dump、线程暂停、线程偏向锁 (biased locking) 接触 |
| ---------------------------------- | ------------------------------------------------------------ |
| 周期性任务线程                     | 这些线程负责定时器时间 (也就是中断)，用来调度周期性操作的执行 |
| GC 线程                            | 这些线程支持 JVM 中不同的垃圾回收活动。                      |
| 编译器线程 | 这些线程在运行时将字节码动态编译成本地平台相关的机器码 |
| 信号分发线程 | 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理 |



## 2.2.JVM 内存区域

![JVM](./assets/jvm/JVM-memory.png)

​	JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域、【JAVA 堆、方法区】、直接内存。

​	线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应)。

​	线程共享区域随虚拟机的启动/关闭而创建/销毁。

​	直接内存并不是 JVM 运行时数据区域的一部分，但也会被频繁的使用：在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见：Java I/O 扩展)，这样就避免了再 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。

![Java-Memory-Area](./assets/jvm/Java-Memory-Area.png)



### 2.2.1.程序计数器

​	一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为"线程私有"的内存。

​	正在执行的 Java 方法的话，计数器记录的是虚拟机字节码指令的地址 (当前指令的地址) 。如果是 Native 方法，则为空。

​	这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况区域。

### 2.2.2.虚拟机栈 (线程私有)

​	虚拟机栈是描述 Java 方法执行的内存模型，每个方法在执行的同事都会创建一个栈帧 (Stack Frame) 用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

​	栈帧 (Stack Frame) 是用来存储数据和部分过程结果的数据结构，同时也被用来动态处理动态链接 (Dynamic Linking)、方法返回值和异常分派 (Dispatch Exception) 。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成异常完成 (抛出了在方法内未被捕获的异常) 都算做方法的结束。



### 2.2.3.本地方法区 (线程私有)

​	本地方法区和 Java Stack 作用类型，区别是虚拟机栈作为执行 Java 方法服务，而本地方法栈为 Native 方法服务，如果一个 VM 实现适用 C-linkage 模型来支持 Native 调用，那么该栈将会是一个 C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

### 2.2.4. 堆 (Heap-线程共享) -运行时数据区

​	堆是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也就是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用**分代收集算法**，因此 Java 堆从 GC 的角度还可以细分为：新生代(Eden 区、From Survivor 区和 To Survivor区) 和**老年代**。

### 2.2.5. 方法区/永久代 (线程共享)

​	即我们常说的**永久代 (Permanent Generation)**，用于存储**被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。HotSpot VM 把 GC 分代收集扩展至方法区，即**使用 Java 堆的永久代来实现方法区**，这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对**常量池的回收**和**类型的卸载**，因此收益一般很小)。

​	运行时常量池 (Runtime Constant Pool) 是方法区的一部分。 Class 文件中除了有了类版本、字段、方法、接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)， 用于存放编译器生成各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对 Class 文件的每一部分 (自然也包括常量池) 的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。

## 2.3.JVM运行时内存

​	Java 堆从 GC 的角度还可以细分为：**新生代** (Eden区、From Survivor 区和 To Survivor 区) 和**老年代**。



### 2.3.1.新生代

​	新生代是用来放新生的对象。一般占据堆得 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServiviorTo三个区。

#### 2.3.1.1. Eden区

​	Java 新对象的出生地 (如果新创建的对象占用内存很大，则直接分配到老年代)。当 Eden 区内存不够的时候回触发 MinorGC，对新生代区进行一次垃圾回收。

#### 2.3.1.2. ServivorFrom

​	上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

#### 2.3.1.3. ServivorTo

​	保留了一次 MinorGC 过程中的幸存者。

#### 2.3.1.4. MinorGC 的过程 (复制->清空->互换)

​	MinorGC 采用复制算法。

**①：eden、servivorFrom 复制到 ServicorTo，年龄+1**

​	首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域 (如果有对象的年龄以及达到了老年的标准，则复制到老年代区)，同时把这些对象的年龄+1 (如果 ServicorTo 不够位置了就放到老年区)；

**②：清空 eden、servicorFrom**

​	然后，清空 Eden 和 ServicorFrom 中的对象；

**③：ServicorTo 和 ServicorFrom 互换**

​	最后，ServicorTo 和 ServicorFrom 互换，源 ServicorTo 成为下一次 GC 时的 ServicorFrom区。



### 2.3.2. 老年代

​	主要存放在应用程序中生命周期长的内存对象。

​	老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了 MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给所创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

​	MajorGC 采用标记清除法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描在回收。MajorGC 会产生内存碎片，为了减少内存消耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM (Out Of Memory) 异常。

### 2.3.3. 永久代

​	永久代是指内存的永久保存区域，主要存放 Class 和 Meta (元数据) 的信息，Class 在被加载的时候被放入永久区域，它和存放示例的区域不同，GC 不会再主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而膨胀，最终抛出 OOM 异常。



#### 2.3.3.1. Java8 与元数据

​	在 Java8 中，永久代已经被移除，被一个称为 "元数据区" (元空间) 的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小受本地内存限制。类的元数据放入 native memory，字符串池和类的静态变量放入 Java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。



## 2.4. 垃圾回收与算法





### 2.4.1. 如何确定垃圾



#### 2.4.1.1. 引用计数法

​	在 Java 中，引用和对象时有关联的。如果要操作对象，必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单来说，即一个对象如果没有任务与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。

#### 2.4.1.2. 可达性分析

​	为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的 "GC roots" 对象作为起点搜索。如果在 "GC roots" 和一个对象之间没有可达路劲，则称该对象是不可达的。

​	需要注意的是，不可达对象不等价可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

### 2.4.2. 标记清除算法 (Mark-Sweep)

​	最基础的垃圾回收算法，分为两个阶段，标记和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图



​	从图中我们就可以发现，该算法最大问题就是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。

### 2.4.3. 复制算法 (copying)

​	为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块，每次只使用其中一块，当这块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清理掉，如图：



​	这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大问题是可用内存被压缩到原来的一半。且存活对象增多的话，Copying 算法的效率会大大的降低。

### 2.4.4. 标记整理