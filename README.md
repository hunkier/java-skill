# JVM

**（1）基本概念**

​	JVM是可运行Java代码的假想计算器，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域。JVM是运行在操作系统之上，它与硬件没有直接的交互。

![JVM](./assets/jvm/JVM.png)



(2)运行过程

​	我们都知道Java源文件，通过编译器，能够产生相应的.class文件，也就是字节码文件，而字节码文件有通过Java虚拟机中的解释器，编译成特定机器上的机器码。

也就是如下：

​	①Java源文件—>编译器—>字节码文件

​	②字节码文件—>JVM—>机器码

​	每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也是Java为什么能够跨平台的原因，当一个程序从开始运行，这是虚拟机就凯斯实例化了，多个程序启动就会存在多个虚拟机示例。程序退出或者关闭，则虚拟机示例消亡，多个虚拟机示例之间数据不能共享。

![JVM](./assets/jvm/Java-Runtime.png)



## 2.1.线程

​	这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot  JVM 中的 Java 线程与原生操作系统的线程有直接的映射关系。当本地线程存储、缓存区分配、同步对象、栈、程序计数器等准备好后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度Java线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。

​	Hotspot JVM 后台运行的系统线程主要有下面几个：

| 虚拟机线程            (VM thread) | 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程中里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有： stop-the-world 垃圾回收、线程 dump、线程暂停、线程偏向锁 (biased locking) 接触 |
| ---------------------------------- | ------------------------------------------------------------ |
| 周期性任务线程                     | 这些线程负责定时器时间 (也就是中断)，用来调度周期性操作的执行 |
| GC 线程                            | 这些线程支持 JVM 中不同的垃圾回收活动。                      |
| 编译器线程 | 这些线程在运行时将字节码动态编译成本地平台相关的机器码 |
| 信号分发线程 | 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理 |



## 2.2.JVM 内存区域

![JVM](./assets/jvm/JVM-memory.png)

​	JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域、【JAVA 堆、方法区】、直接内存。

​	线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应)。

​	线程共享区域随虚拟机的启动/关闭而创建/销毁。

​	直接内存并不是 JVM 运行时数据区域的一部分，但也会被频繁的使用：在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见：Java I/O 扩展)，这样就避免了再 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。

![Java-Memory-Area](./assets/jvm/Java-Memory-Area.png)



### 2.2.1.程序计数器

​	一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为"线程私有"的内存。

​	正在执行的 Java 方法的话，计数器记录的是虚拟机字节码指令的地址 (当前指令的地址) 。如果是 Native 方法，则为空。

​	这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况区域。

### 2.2.2.虚拟机栈 (线程私有)

​	虚拟机栈是描述 Java 方法执行的内存模型，每个方法在执行的同事都会创建一个栈帧 (Stack Frame) 用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

​	栈帧 (Stack Frame) 是用来存储数据和部分过程结果的数据结构，同时也被用来动态处理动态链接 (Dynamic Linking)、方法返回值和异常分派 (Dispatch Exception) 。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成异常完成 (抛出了在方法内未被捕获的异常) 都算做方法的结束。



### 2.2.3.本地方法区 (线程私有)

​	本地方法区和 Java Stack 作用类型，区别是虚拟机栈作为执行 Java 方法服务，而本地方法栈为 Native 方法服务，如果一个 VM 实现适用 C-linkage 模型来支持 Native 调用，那么该栈将会是一个 C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

### 2.2.4. 堆 (Heap-线程共享) -运行时数据区

​	堆是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也就是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用**分代收集算法**，因此 Java 堆从 GC 的角度还可以细分为：新生代(Eden 区、From Survivor 区和 To Survivor区) 和**老年代**。

### 2.2.5. 方法区/永久代 (线程共享)

​	即我们常说的**永久代 (Permanent Generation)**，用于存储**被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。HotSpot VM 把 GC 分代收集扩展至方法区，即**使用 Java 堆的永久代来实现方法区**，这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对**常量池的回收**和**类型的卸载**，因此收益一般很小)。

​	运行时常量池 (Runtime Constant Pool) 是方法区的一部分。 Class 文件中除了有了类版本、字段、方法、接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)， 用于存放编译器生成各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对 Class 文件的每一部分 (自然也包括常量池) 的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。

## 2.3.JVM运行时内存

​	Java 堆从 GC 的角度还可以细分为：**新生代** (Eden区、From Survivor 区和 To Survivor 区) 和**老年代**。



### 2.3.1.新生代

​	新生代是用来放新生的对象。一般占据堆得 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServiviorTo三个区。

#### 2.3.1.1. Eden区

​	Java 新对象的出生地 (如果新创建的对象占用内存很大，则直接分配到老年代)。当 Eden 区内存不够的时候回触发 MinorGC，对新生代区进行一次垃圾回收。

#### 2.3.1.2. ServivorFrom

​	上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

#### 2.3.1.3. ServivorTo

​	保留了一次 MinorGC 过程中的幸存者。

#### 2.3.1.4. MinorGC 的过程 (复制->清空->互换)

​	MinorGC 采用复制算法。

**①：eden、servivorFrom 复制到 ServicorTo，年龄+1**

​	首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域 (如果有对象的年龄以及达到了老年的标准，则复制到老年代区)，同时把这些对象的年龄+1 (如果 ServicorTo 不够位置了就放到老年区)；

**②：清空 eden、servicorFrom**

​	然后，清空 Eden 和 ServicorFrom 中的对象；

**③：ServicorTo 和 ServicorFrom 互换**

​	最后，ServicorTo 和 ServicorFrom 互换，源 ServicorTo 成为下一次 GC 时的 ServicorFrom区。



### 2.3.2. 老年代

​	主要存放在应用程序中生命周期长的内存对象。

​	老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了 MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给所创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

​	MajorGC 采用标记清除法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描在回收。MajorGC 会产生内存碎片，为了减少内存消耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM (Out Of Memory) 异常。

### 2.3.3. 永久代

​	永久代是指内存的永久保存区域，主要存放 Class 和 Meta (元数据) 的信息，Class 在被加载的时候被放入永久区域，它和存放示例的区域不同，GC 不会再主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而膨胀，最终抛出 OOM 异常。



#### 2.3.3.1. Java8 与元数据

​	在 Java8 中，永久代已经被移除，被一个称为 "元数据区" (元空间) 的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小受本地内存限制。类的元数据放入 native memory，字符串池和类的静态变量放入 Java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。



## 2.4. 垃圾回收与算法





### 2.4.1. 如何确定垃圾



#### 2.4.1.1. 引用计数法

​	在 Java 中，引用和对象时有关联的。如果要操作对象，必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单来说，即一个对象如果没有任务与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。

#### 2.4.1.2. 可达性分析

​	为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的 "GC roots" 对象作为起点搜索。如果在 "GC roots" 和一个对象之间没有可达路劲，则称该对象是不可达的。

​	需要注意的是，不可达对象不等价可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

### 2.4.2. 标记清除算法 (Mark-Sweep)

​	最基础的垃圾回收算法，分为两个阶段，标记和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图



​	从图中我们就可以发现，该算法最大问题就是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。

### 2.4.3. 复制算法 (copying)

​	为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块，每次只使用其中一块，当这块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清理掉，如图：



​	这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大问题是可用内存被压缩到原来的一半。且存活对象增多的话，Copying 算法的效率会大大的降低。

### 2.4.4. 标记整理 (Mark-Compact)

​	结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活的对象移向内存的一段。然后清除端边界外的对象。如图：



### 2.4.5.分代收集算法

​	分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation) 和新生代 (Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。



#### 2.4.5.1.新生代与复制算法

​	目前大部分 JVM 的 GC 对于新生代都采用 Coping 算法，因为新生代中每次垃圾回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间 (From Space，To Space)，每次使用 Eden空间和其中一块 Survivor 空间，当进行回收时，将两块空间中还存活的对象分，复制到另外一块 Survivor空间中。



#### 2.4.5.2. 老年代与标记复制算法

​	而老年代因为每次回收少量对象，因而采用 Mark-Compact算法。

1. Java 虚拟机提到过的处于方法区的永久代 (Permanet Generation)，它用来存储 class类、常量、方法描述等。对永生代的回收主要包括废弃的常量和无用的类。

2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space (Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。

3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。

4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。

5. 在进行 GC 后，使用的便是 Eden Space 和 To Space了，如此反复循环。

6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄达到 15 的对象会被移到老生代中。

   

   ## 2.5. Java 四种引用类型

   ### 2.5.1. 强引用

   ​	在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它是处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。

   ### 2.5.2. 软引用

   ​	软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存不足时它会被回收。软引用通常在对内存敏感的程序中。

### 2.5.3. 弱引用

​	弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存是否足够，总会回收改对象占用的内存。

### 2.5.4. 虚引用

​	虚引用需要用 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。



## 2.6. GC 分代收集算法 VS 分区收集算法



### 2.6.1. 分代收集算法

​	当前主流 VM 垃圾收集都采用" 分代收集 ” (Generational Collection) 算法，这种算法会根据对象存活周期的不同将内存划分为几块，如 JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法。

#### 2.6.1.1. 在新生代-复制算法

​	每次垃圾收集都能发现大批对象已死，只有少量存活。因此选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

#### 2.6.1.2. 在老年代-标记整理算法

​	因为对象存活率高、没有额外空间对它进行分配担保，就必须采用 "标记—清理" 或 "标记—整理" 算法来回收，不必进行内存复制，且直接腾出空闲内存。

### 2.6.2. 分区收集算法

​	分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间 (而不是整个堆)，从而减少一次 GC 所产生的停顿。

## 2.7. GC 垃圾收集器

​	Java 堆内存被划分为新生代和年老代，新生代主要使用复制和标记—清理垃圾回收算法；年老代主要使用标记—整理垃圾回收算法，因此 Java 虚拟机中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK 1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：





### 2.7.1. Serial 垃圾收集器 (单线程、复制算法)

​	Serial (英文连续) 是最基本垃圾收集器，使用复制算法，曾经是 JDK1.3.1 之前新生代唯一的垃圾收集器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。

​	Serial 垃圾收集器虽然在手机垃圾过程中需要停止所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销。可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是 Java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。

### 2.7.2. ParNew 垃圾收集器 （Serial + 多线程）

​	ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也是用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。

​	ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过 -XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】

​	ParNew 虽然是除了多线程外和 Serial 收集器几乎完全一样，但是 ParNew 垃圾收集器是很多 Java 虚拟机在 Server 模式下新生代的默认垃圾收集器。

### 2.7.3. Parallel Scavenge 收集器 （多线程复制算法、高效）

​	Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样适用复制算法，也是一个多线程垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量 （Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率的利用 CPU 时间，尽快的完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。

### 2.7.4. Serial Old 收集器 （单线程标记整理算法）

​	Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记—整理算法。这个收集器也主要是运行在 Client 默认的 Java 虚拟机的年老代垃圾收集器。

​	在 Server 模式下，主要有两个用途：

1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。

2. 作为老年代中使用 CMS 收集器的后备垃圾方案。

   新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：





​	新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理相似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/Parnew 与年老代 Serial Old 搭配垃圾收集过程图：



### 2.7.5. Parallel Old 收集器（多线程标记整理算法）

​	Parallel Old 收集器是 Parallel Scavenge 的年老代版本，使用多线程的标记—整理算法，在 JDK1.6 才开始提供。

​	在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配策略。

​	新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：



### 2.7.6. CMS 收集器 （多线程标记清除算法）

​	Concurrent mark sweep （CMS）收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾收停顿时间。和其他年老代使用标记—整理算法不同，它使用多线程的标记—清除算法。

​	最短垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

​	CMS 工作机制相比其他垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：

#### 2.7.6.1. 初始标记

​	只是标一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。

#### 2.7.6.2. 并发标记

​	进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。

#### 2.7.6.3. 重新标记

​	为了修正正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。

#### 2.7.6.4. 并发清除

​	清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作，所以总体上来看 CMS 收集器的内存回收和用户线程是一起并发地执行。

CMS 收集器工作过程：





### 2.7.7. G1 收集器

​	Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比于 CMS 收集器，G1 收集器两个突出的改进是：

1.基于标记—整理算法，不产生内存碎片。

2.可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在优先时间获得最高的垃圾收集效率。

## 2.8. JAVA IO/NIO

### 2.8.1. 阻塞 IO 模型

​	最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read()；如果数据没有就绪，就会一直阻塞在read方法。

### 	2.8.2. 非阻塞 IO 模型

​	当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是他可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户的线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：

```java
while(true){
	data = socket.read();
	if(data != error){
    // 处理数据
    break;
	}
}
```

但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。

### 2.8.3. 多路复用 IO 模型

​	多路复用 IO 模型是目前使用得比较多的模型。 Java NIO 实际上就是多路复用 IO。在多路复用 IO 模型中，会有一个线程不断的去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select() 去查询每个通道是否有到达事件，所以没有事件，则一直阻塞在那里，因此这种方式会导致用户线程阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。

​	另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高德多。

​	不过需要注意的是，多路复用 IO 模型是通过轮询方式来检测是否有时间到达，并且对到达的事件逐一进行响应。对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响到新的事件轮询。

### 2.8.4. 信号驱动 IO 模型

​	在信号驱动 IO 模型中，当用户线程发起一个 IO 操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程收到信号后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。

### 2.8.5. 异步 IO 模型

​	异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其他的事。而另一方面，从内核的角度，当它收到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就是说用户线程完全不需要了解整个 IO 操作是如何进行的，只需要发起一个请求，当解说内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。

​	也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点事和信号驱动模型有所不同在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。

注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO 。

## 2.9.1. JAVA IO 包



### 2.9.2.  Java NIO

​	NIO 主要有三大核心部分： Channel（通道），Buffer（缓冲器），Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer （缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector （选择区）用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。



​	NIO 和传统 IO 之间最大的区别是，IO 是面向流的，NIO 是面向缓冲的。

### 2.9.2.1. NIO 的缓冲区

​	Java IO 面向流意味着每次从流中读一个或者多个字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向和方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需要确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

### 2.9.2.2. NIO 的非阻塞

​	IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或者 write() 时，该线程是被阻塞，直到有一些数据被读取，或数据被完全写入。该线程在此期间不能再干任何事情了。NIO 的非阻塞模式，使一个线程线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可以用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通信将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

### 2.9.3. Channel

​	首先说一下 Channel，国内大多翻译成 “通道” 。Channel 和 IO 中的 Stream（流）是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream，而 Channel 是双向的，即可以用来进行读操作，又可以用来进行写操作。

NIO 中的 Channel 的主要实现有：

1. FileChannel

2. DatagramChannel

3. SocketChannel

4. ServerSocketChannel

   

这里看名字就可以猜出个所以然来：分别对应文件 IO、UDP 和 TCP （Server 和 Client）。

下面演示的案例基本上就是围绕这4个类型的 Channel进行陈述的。

   

### 2.9.4. Buffer

​	Buffer，顾名思义，缓冲区，实际上是一个容器，使一个连续数组。Channel 提供从文件、网络读取数据的渠道，当是读取或写入的数据都必须经由 Buffer。





​	上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这个接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。

​	在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：ByteBuffer、IntBuffer、CharBuffer、LongBuffer、DoubleBuffer、FloatBuffer、ShortBuffer

### 2.9.5. Selector

​	Selector 类是 NIO 的核心类，Selector 能够检测多个注册通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大的减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，避免了多线程之间的上下文切换导致的开销。



## 2.10. JVM 类加载机制

​	JVM 类加载机制分为五个部分：加载、验证、准备、解析、初始化，下面我们就分别来看一下这五个过程。







#### 2.10.1.1. 加载

​	加载时类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件读取，这里即可以从 ZIP 包中读取 （比如 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其他文件生成（比如 JSP 文件转换成对应 Class 类）。

#### 2.10.1.2. 验证

​	这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

#### 2.10.1.3. 准备

​	准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里说的初始值概念，比如一个类变量定义为：

```java
public static int v = 8080;
```

​	实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器 <client> 方法中。

​	但是注意如果声明为：

```java
public static final int v = 8080;
```

​	在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080 。

#### 2.10.1.4. 解析

​	解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

1. CONSTANT_Class_info

2. CONSTANT_Field_info

3. CONSTANT_Method_info

等类型的常量。

#### 2.10.1.5. 符号引用

- 符号引用与虚拟机实现布局无关，引用的目标不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，当是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。

#### 2.10.1.6. 直接引用
- 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
  
#### 2.10.1.7.  初始化

​	初始化阶段是类加载最后一个阶段，前面的类加载之后，除了在加载阶段可以自定义类加载器外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行勒种定义的 Java 程序代码。

#### 2.10.1.8. 类构造器 <client>

​	初始化阶段是执行类构造器 <client> 方法的过程。<client> 方法是由编译器自动收集类中的类变量的赋值和静态语句块中的语句合并而成的，虚拟机会保证子 <client> 方法执行之前，父类的 <client> 方法已经执行完毕，如果一个类中没有对静态变量赋值也没静态语句块，那么编译器可以不为这个类生成 <client>() 方法。

​	注意以下几种情况不会执行类初始化：

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
4. 通过类名获取 Class 对象，不会触发类的初始化。
5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。

### 2.10.2. 类加载器

​	虚拟机设计团队吧加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需要的类，JVM 提供了 3 中类加载器：

#### 2.10.2.1. 启动类加载器(Bootstrap ClassLoader)

1. 负责加载 JAVA_HOME\lib 目录中的，或者通过 -Xbootclasspath 参考指定路径中的，且被虚拟机认可 (按文件名称识别，如 rt.jar) 的类

#### 2.10.2.2. 扩展类加载器(Extension Classloader)

 2. 负责加载 JAVA_HOME\lib\ext 目录中的，或者通过 java.ext.dirs 系统变量指定路径中的类库。

#### 2.10.2.3. 应用程序类加载器

 3. 负责加载用户路径 (classpath) 上的类库。

    JVM 通过双亲委派模型进行类加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。



### 2.10.3. 双亲委派

​	当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候 (在它的加载路径下没有找到所需要加载的 Class)，子类加载器才会尝试自己去加载。

​	采用双亲委派的一个好处就是比如加载位于 rt.jar 包中的 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个 Object 对象。









### 2.10.4. OSGI (动态模型熊)

​	OSGI(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。



#### 2.10.4.1. 动态改变构造

​	OSGI 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGI 技术提供一种面向服务的架构，它能使这些组件动态地发下对方。



#### 2.10.4.2. 模块化编程与热插拔

​	OSGI 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGI 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业程序开发来说是非常具有诱惑力的特性。

​	OSGI 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标所需要的服务与框架，同时也有成熟的框架实现支持。但并非所有的应用都适合采用 OSGI 作为基础架构，它在提供强大功能的同时，也引入了额外的复杂度，因为他不遵守了类加载器的双亲委派模型。



# 3. JAVA 集合

## 3.1. 接口继承关系和实现

​	集合类存放在 Java.util 包中，主要有 3 种：set(集)、list(列表包含 Queue)和map(映射)。

1. Collection：Collection 是集合 List、Set、Queue 的最基本的接口。
2. Iterator：迭代器，可以通过迭代器遍历集合中的数据。
3. Map：是映射表的基础接口。















## 3.2. List

​	Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。









### 3.2.1. ArrayList (数组)

​	ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已有数组复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动的代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。

### 3.2.2. Vector (数组实现、线程同步)

​	Vector 和ArrayList 一样，也是通过数组实现的，不同的是它支持线程同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此访问它比访问 ArrayList 慢。

### 3.2.3. LinkList (链表)

​	LinkedList 是链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，它还提供了 List 接口中没有定义的方法，专门用于操作表头和表位元素，可以当作堆栈、队列和双向队列使用。



## 3.3. Set

​	Set 注重独一无二的性质，该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值 (java 是依据对象的内存地址计算出的此序号) 判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的hashCode 方法和 equals 方法。

### 3.3.1.1. HashSet (Hash 表)

​	哈希表里面存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序 (和 List 显然不同)，而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashCode 方法来获取的，HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法来获取的，HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法，如果 equals 结果为true，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。

​	哈希值相同 equals 为 false 的元素是怎么存储呢，就是在同样的哈希值下顺延 (可以认为哈希值相同的元素放在一个哈希桶中)。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。

​	HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。

#### 3.3.1.2. TreeSet (二叉树)

1. TreeSet 是使用二叉树的原理堆新 add() 的对象按照指定的顺序 (升序、降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。
2. Integer 和 String 对象可以进行默认的TreeSet 排序，而自定义类的对象是不可以的，自定义类必须实现 Comparable 接口，并且覆写响应的 compareTo() 函数，才可以正常使用。
3. 在覆写 compare() 函数视，要返回相应的值才能使 TreeSet 按照一定的规则来排序
4. 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则返回负整数、零或正整数。

#### 3.3.1.3. LinkHashSet (HashSet + LinkedHashMap)

​	对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承于 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。



## 3.4. Map







### 3.4.1. HashMap (数组+链表+红黑树)

​	HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以由多个线程同时写 HashMap，可能会导致数据不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法是 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。



#### 3.4.1.1. Java 7 实现

**Java7 HashMap 结构**







​	大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key，value，hash 值和用于单向链表的 next。

1. capacity：当前数组容量，始终保持在 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
2. loadFactor：负载因子，默认为 0.75.
3. threshold：扩容的阈值，等于 capacity*loadFactor.



#### 3.4.1.2. JAVA8 实现

​	Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由数组+链表+红黑树组成。

​	根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速的定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logn)。

**Java8 HashMap 结构**







### 3.4.2. ConcurrentHashMap

#### 3.4.2.1. Segment 段

​	ConcurrentHashMap 和 HashMap 思路差不多，当是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表"部分"或"一段"的意思，所以很多地方将其描述为分段锁。注意，行文中，我很多地方用了"槽"来代表一个 segment。

#### 3.4.2.2. 线程安全 (Segment 继承 ReentrantLock)

​	简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 Segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。

**Java7 ConcurrentHashMap**







#### 3.4.2.3. 并行度 (默认16)

​	concurrentLevel: 并行级别、并发数、Segment数，怎么翻译不重要，理解它。默认是16，也就是说 ConcurrentHashMap 有 16 个 Segment，所以理论上，这个时候，最多可以同时支持 16 个线程并发，只要它们分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化后，它是不可以扩容的。在具体到每个 Segment 内部，其实每个 Segment 很像之间介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。

#### 3.4.2.4. Java8 实现 (引入了红黑树)

​	Java8 对 ConcurrentHashMap 进行了比较大的改动，Java8 也引入了红黑树。

**Java8 ConcurrentHashMap 结构**







### 3.4.3. HashTable (线程安全)

​	Hashtable 遗留类，很多映射的常用功能与 HashMap 类似，不同的是它继承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 HashTable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。HashTable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。

### 3.4.4. TreeMap (可排序)

​	TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。

​	如果使用排序的映射，建议使用 TreeMap。

​	在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型异常。

### 3.4.5. LinkHashMap (记录插入顺序)

​	LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入，也可以在构造时带参数，按照访问次序排序。



# 4. Java 多线程并发

### 4.1.1.  Java 并发知识库







### 4.1.2. Java 线程实现/创建方式

#### 4.1.2.1. 继承 Thread 类

​	Thread 类本质上是实现了 Runnable 接口的一个实例。启动线程的唯一方法就是通过 Thread 类的 start() 实例方法。start() 方法是一个 native 方法，它将启动一个新线程，并执行 run() 方法。

```java
public class MyThread extends Thread {
		public void run() {
				System.out.println("MyThread.run()");
		}
}
MyThread myThread1 = new MyThread();
myThread1.start();

```

#### 4.1.2.2. 实现 Runnable 接口

​	如果自己的类已经 extends 另外一个类，就无法直接 extends Thread，此时实现一个 Runnable 接口。

```java
public 	class MyThread extends OtherClass Implements Runnable {
  public void run() {
    System.out.println("MyThread.run()");
  }
}
// 启动一个 MyThread，需要先实例化一个 Thread，并传入自己的 MyThread 实例：
MyThread mythread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();
// 事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run() 方法就会调用 target.run()
public void run() {
  if (target != null ){
    target.run();
  }
}
```

#### 4.1.2.3. ExecutorService、Callable<Class>、Future 有返回值线程

​	有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行 Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合 ExcutorService 就可以实现传说中有返回结果的多线程了。

```java
public class MyCallable implements Callable<Object> {
  Object call() throws Exception{
    // 处理业务逻辑 TODO
    Object obj = new Object();
    // 返回处理结果
    return obj;  
  }
}


// 创建一个线程
ExecutorService pool = Executors.newFixedThreadPool(taskSize);
// 创建多个有返回值的任务
List<Future> list = new ArrayList<Futrue>();
for(int i = 0 ; i < taskSize; i++){
  Callable c = new MyCallable(i+"");
  // 执行任务并获取 Future 对象
  Future f = pool.submit(c);
  list.add(f);
}
// 关闭线程池
pool.shutdown();
// 获取所有并发任务的运行结果
for (Future f : list) {
  // 从 Future 对象上获取任务的返回值，并输出到控制台
  System.out.println("res: " + f.get().toString());
}
```



### 4.1.3. 4 种线程池

​	Java 里面线程池的顶级接口是 Executor，当是严格意义上讲 Executor 并不是一个线程池，而是一个执行线程的工具。真正的线程池接口是 **ExecuteService**。









#### 4.1.3.1. newCachedThreadPool

​	创建一个可根据需要创建新线程的线程池，但是在以后构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序的性能。调用 execute 将重用以前构造的线程 (如果线程可用)。如果现在线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任务资源。



#### 4.1.3.2. newFixThreadPool

​	创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 Threads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务 (如果需要)。在某个线程被显式地关闭之前，池中的线程将一直存在。

#### 4.1.3.3.  newScheduledThreadPool

​	创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行

```java
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
scheduledThreadPool.schedule(new Runnable(){
  @Override
  public void run() {
    System.out.println("延迟三秒！");
  }
}, 3, TimeUnit.SECONDS);

scheduledThreadPool.scheduleAtFixedRate(new Runnable(){
  @Override
  public void run(){
    System.out.println("延迟1秒后每三秒执行一次！");
  }
}, 1, 3, TimeUnit.SECONDS);
```

#### 4.1.3.4. newSingleThreadExecutor

​	Executors.newSingleThreadExecutor() 返回一个线程池 (这个线程池只有一个线程)，这个线程池可以在线程死后 (或发生异常时) 重新启动一个线程来替代原来的线程继续执行下去！

### 4.1.4. 线程生命周期(状态)

​	当线程被创建并启动以后，它既不是一启动就进入执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建 (New)、就绪 (Runnable)、运行 (Running)、阻塞 (Blocked) 和死亡 (Dead) 5中状态。尤其是当多线程启动以后，它不可能一直 "霸占" 着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。



#### 4.1.4.1. 新建状态 (NEW)

​	当一程序使用 new 关键字创建一个线程之后，改线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值

#### 4.1.4.2. 就绪状态 (RUNNABLE)

​	当线程对象调用了 start() 方法之后，该线程处于就绪状态。 Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

#### 4.1.4.3. 运行状态 (RUNNING)

​	如果处于就绪状态的线程获得了 CPU，开始执行 run() 方法的线程执行体，则该线程处于运行状态。

#### 4.1.4.4. 阻塞状态 (BLOCKED)

​	阻塞状态时指线程因为某种原因放弃了 CPU 使用权，也立即让出了 CPU timeslice，暂时停止运行。直到线程进入可运行 (runnable) 状态，才有机会再次获得 CPU timeslice 转到运行 (running) 状态。阻塞的情况分三种：

**等待阻塞 (o.wait->等待队列)：**

​	运行 (running) 的线程执行 o.wait() 方法，JVM 会把该线程放入等待队列 (waitting queue) 中。

**同步阻塞 (lock->锁池)：**

​	运行 (running) 的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池 (lock pool) 中。

**其他阻塞 (sleep|join)**

​	运行 (running) 的线程执行 Thread.sleep(long ms) 或 t.join() 方法，或者发出 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I\O处理完毕，线程重新转入可运行 (running) 状态。

#### 4.1.4.5. 线程死亡 (DEAD)

​	线程会以下面三种方式结束，结束后就是死亡状态。

**正常结束**

1. run() 或 call() 方法执行完成，线程正常结束。

**异常结束**

2. 线程抛出一个未捕获的 Exception 或 Error。

**调用 stop**

3. 直接调用该线程的 stop() 方法来结束该线程——该方法容易导致死锁，不推荐使用。









### 4.1.5. 终止线程4中方式

#### 4.1.5.1. 正常运行结束

​	程序运行结束，线程自动结束。

#### 4.1.5.2. 使用退出标志退出线程

​	一般 run() 方法执行完，线程就会正常结束，然而，常常有一些线程是私服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设置一个 Boolean 类型标志，并通过设置这个标志为 true 或 false 来控制 while 循环是否退出，代码示例：

```java
public class ThreadSafe extends Thread {
  public volatile boolean exit = false;
  public void run() {
    while(!exit){
      // do something
      
    }
  }
}
```

定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false。在定义 exit时，使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。



#### 4.1.5.3. Interrupt 方法结束线程

​	使用 interrupt() 方法来中断线程有两种情况：

1. 线程处于阻塞状态：如使用了 sleep，同步锁的 wait，socket 中的 receiver，accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt() 方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的，一定要先捕获 InterruputedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。

2. 线程未处于阻塞状态：使用 isInterrupted() 判断线程的中断标志来退出循环。当使用 interrupt() 方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。

   ```java
   public class ThreadSafe extends Thread {
     public void run() {
       while (!isInterrupted()){// 非阻塞过程通过判断中断标志来退出
         try{
           Thread.sleep(5*1000);// 阻塞过程捕获中断异常来退出
         }catch(InterruptedException e){
           e.printStackTrace();
           break;// 捕获到异常之后，执行 break 跳出循环
         }
       }
     }
   }
   ```

   #### 4.1.5.4. stop 方法终止线程 (线程不安全)

   ​	程序中可以直接使用 thread.stop() 来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop() 调用之后，创建子线程的线程会抛出 ThreadDeatherror 的错误，并且会释放子线程持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用 thread.stop() 后导致了该线程所持有的所有锁突然释放(不可控制)，那么被保护数据就有可能呈现不一致，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。

   ### 4.1.6. sleep 和 wait 区别

   1. 对于 sleep() 方法，我们首先要知道该方法是属于 Thread 类中的。而 wait() 方法，则是属于 Object 类中的。
   2. sleep() 方法导致了程序暂停执行指定的时间，让出 cpu 给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会恢复运行状态。
   3. 在调用 sleep() 方法过程中，线程不会释放对象锁。
   4. 而当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify() 方法后本线程才进入对象锁进入运行状态。

### 4.1.7. start 与 run 区别

1. start() 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。

2. 通过 Thread 类的 start() 方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。

3. 方法 run() 称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。Run 方法运行结束，此线程终止。然后 CPU 再调度其他线程。

### 4.1.8. Java 后台线程

1. 定义：守护线程——也称 "服务线程"，他是后台线程，它有一个特性，即为用户线程，提供公共服务，在没有用户线程可服务时会自动离开。
2. 优先级：守护线程的优先级比较低，用于为系统中的其他对象和线程提供服务。
3. 设置：通过 setDaemon(true) 类设置线程未 "守护线程" ；将一个用户线程设置为守护线程的方式是在线程对象创建之前用线程对象的 setDaemon 方法。
4. 在 Daemon 线程中产生的新线程也是 Daemon 的。
5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用保持同步。也就是说，即使你停止 Web 应该，这个线程依旧是活跃的。
6. example：垃圾回收线程就是一个经典的守护线程，当我们的程序不再有任何运行的 Thread，程序就不会再产生垃圾，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。
7. 生命周期：守护进程 (Daemon) 是运行在后台的一种特殊进程。它独立于控制终端并周期性地执行某种任务或等待处理某些发生的事情。也就是说守护线程不依赖终端，但是依赖系统，与系统 "同生共死" 。当 JVM 中所有的线程都是守护线程的时候， JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。



### 4.1.9. Java 锁

#### 4.1.9.1. 乐观锁

​	乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，当是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读取当前的版本号，然后加锁操作 (比较跟上一次的版本号，如果一样则更新)，如果失败则需要重复读-比较-写的操作。

​	Java 中的乐观锁基本都是通过 CAS 操作实现，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

#### 4.1.9.2. 悲观锁

​	悲观锁就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在写数据的时候都会上锁，这样别人想写这个数据就会 block 直到拿到锁。java 中悲观锁就是 Synchronized，AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到，才会转为悲观锁，如 RetreenLock。

#### 4.1.9.3. 自旋锁

​	自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等 (自旋)，等持有锁的线程释放后即可立即获取锁，这样就避免用户线程和内核切换的消耗。

​	线程自旋是需要消耗 cpu 的，说白了在做 无用功，如果一直获取不到锁，那线程也不能一直占用 cpu 自旋做无用功，所以要设定一个自旋等待的最大时间。

​	如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。

**自旋锁的优缺点**

​	自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁锁时间非常短的代码块来说性能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒操作的消耗，这些操作会导致线程发生两次上下文切换！

​	但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其他需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；

**自旋锁时间阈值 (1.6 引入了适应性自旋锁)**

​	自旋锁的目的是为了站着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！

​	JVM 对于自旋周期的选择，jdk1.5 这个限度是一定写死的，在 1.6 引入了自适应自旋锁，适应性自旋意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定，基本认为一个线程上下文切换时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超狗 (CPUs/2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间 (自旋计数) 或进入阻塞，如果 CPU 处于节能模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟 (CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差)，自旋时会适当放弃线程优先级之间的差异。

**自旋锁的开启**

JDK 1.6 中 -XX:+UseSpinning 开启；

-XX:PreBlockSpin=10 为自旋次数；

JDK 1.7 后，去掉此参数，由 jvm 控制；



#### 4.1.9.4. Synchronized 同步锁

​	Synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占锁的悲观锁，同时属于可重入锁。

**Synchronized 作用范围**

1. 作用于方法时，锁住的是对象的实例 (this)；
2. 当作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据存储在永久代 PermGen (jdk 1.8 则是 metaspace)，永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程。
3. synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。

Synchronized 核心组件

​	1）Wait Set：那些调用 wait 方法被阻塞的线程被放置在这里；

​	2）Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；

​	3）Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；

​	4）OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为 OnDeck；

​	5）Owner：当前已经获取到所有资源的线程被称为 Owner；

​	6）!Owner：当前释放锁的线程。

**Synchronized 实现**







1. JVM 每次从队列尾部取出一个数据用于竞争候选者 (OnDeck)，当是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。
2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中某个线程为 OnDeck 线程 (一般是最先进去的那个线程)。
3. Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，当是能极大的提升系统吞吐量，在 JVM 中，也把这种选择行为称之为 "竞争切换"。
4. OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果Owner线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify 或者 notifyAll 唤醒，会重新进入 EntryList中。
5. 处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的 (Linux 内核下采用 pthread_mutex_lock 内核函数实现的 )。
6. Synchronized 是非公平锁。Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。
7. 每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块是在前后分别加上 monitorenter 和 moniterexit 指令来实现的，方法加锁是通过一个标记位来判断的。
8. synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的有可能给线程加锁消耗的时间比有用操作消耗的时间更多。
9. Java1.6 ，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。
10. 锁可以从偏向锁升级到轻量级锁，在升级到重量级锁。这种升级过程叫做锁膨胀；
11. JDK1.6 中默认是开启偏向锁的轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。

#### 4.1.9.5. ReentrantLock

​	ReentrantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。

**Lock 接口的主要方法**

1. void lock(): 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁，相反，如果锁已经被其他线程持有，将禁用当前线程获取到锁。
2. boolean tryLock(): 如果锁可用，则获取锁，并立刻返回 true，否则返回 false。该方法和 lock() 的区别在于，tryLock() 只是 "试图" 获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而 lock() 方法则是医药获取到锁，如果锁不可用，就一直在等待，在未获得锁之前，当前线程并不继续向下执行。
3. void unlock(): 执行此方法时，当前线程将释放持有的锁。锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生。
4. Condition newCondition(): 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await() 方法，而调用后，当前线程将释放锁。
5. getHoldCount(): 查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。
6. getQueueLength(): 返回正等待获取此锁的线程计数，比如启动10个线程，1个线程获取到锁，此时返回的是 9 。
7. getWaitQueueLength: ( Condition condition ) 返回等待与此锁相关的给定条件的线程计数。比如 10 个线程，用同一个 condition 对象，并且此时这个 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10 。
8. hasWaiters( Condition condition ): 查询是否有线程等待与此锁有关的给定条件( condition )，对于指定 condition 对象，有多少线程执行了 condtion.await 方法。
9. hasQueueThread( Thead thread ): 查询给定线程是否等待获取此锁。
10. hasQueueThreads(): 是否有线程等待此锁。
11. isFair(): 该锁是否公平锁。
12. isHeldByCurrentThread(): 当前线程释放保持锁锁定，线程执行 lock 方法的前后分别是 false 和 true。
13. isLock(): 此锁是否有任意线程占用。
14. lockInterruptibly(): 如果当前线程未被中断，获取锁。
15. tryLock(): 尝试获取锁，仅在调用时锁未被线程占用，获取锁。
16. tryLock( long timeOut, TimeUnit unit): 如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。

**非公平锁**

​	JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认非公平锁。非公平锁实际执行效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。

**公平锁**

​	公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。

**ReentrantLock 与 synchronized**

1. ReentrantLock 通过方法 lock() 与 unlock() 来进行加锁与解锁操作，与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock 必须在 finally 控制块中进行解锁操作。
2. ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。

**ReentrantLock 实现**

```java
public class MyService {
  private Lock lock = new ReentrantLock();
  // Lock lock = new ReentrantLock(true);
  // Lock lock = new ReentrantLock(false);
  private Condition condition = lock.newCondition();// 创建 Condition
  public void testMethod() {
    try {
      lock.lock();// lock 加锁
      // 1: wait 方法等待
      // System.out.println("开始 wait ");
      condition.await();
      // 通过创建 Condition 对象来是线程 wait，必须先执行 lock.lock 方法获得锁
      // 2：signal 方法唤醒
      condition.signal();// condition 对象的 signal 方法可以唤醒 wait 线程
      for (int i = 0; i < 5; i++){
        System.out.println("ThreadName=" + Thread.currentThread().getName() + ("" + (i+1)));
      }
    }catch (InterruptedException e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }
}
```

**Condition 类和 Object 类锁方法对比**

1. Condition 类的 await 方法和 Object 类的 wait 方法等效。
2. Condition 类的 signal 方法和 Object 类的 notify 方法等效。
3. Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效。
4. ReentrantLock 类可以唤醒指定条件的线程，而 Object 的唤醒是随机的。

**tryLock 和 lock 和 lockInterruptibly 的区别**

1. tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout, TimeUnit unit)，可以增加时间限制，如果超过该时间还没获得锁，返回 false。
2. lock 能获取锁就返回 true，不能的话一直等待获取锁。
3. lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。

#### 4.1.9.6. Semaphore 信号量

​	Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池、资源池之类的，比如数据库连接池。

**实现互斥锁 ( 计算器为1 )**

我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥的机制，这也叫二元信号量，表示两种互斥状态。

**代码实现**

它的用法如下：

```java
// 创建一个计数阈值为 5 的信号对象
// 只能 5 个线程同时访问
Semaphore semp = new Semaphore(5);
try {
  semp.acquire();
  try {
    // 业务逻辑
  } catch (Exception e) {
    
  } finally {
    // 释放许可
    semp.release();
  }
} catch (InterruptedException e){
  
}
```

**Semaphore 与 ReentrantLock**

​	Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire() 与 release() 方法来获得和释放临界资源。经实测，Semaphore.acquire() 方法默认可以响应中断锁，与 ReentrantLock.lockInterruptibly() 作用效果一致，也就是说在等待临界资源的过程中可以被 Thread.interrupt() 方法中断。

​	此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。

​	Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。

#### 4.1.9.7. AtomicInteger

​	首先说明，此处的 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在于运算对象的类型的不同。令人兴奋地，还可以通过 AtomicReference<V> 将一个对象的所有操作转化为原子操作。

​	我们知道，在多线程程序中，诸如 ++i 或 i++ 等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将这个操作变成一个原子操作，但 JVM 为此操作类特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常 AtomicInteger 的性能是 ReentrantLock 的好几倍。

#### 4.1.9.8. 可重入锁 (递归锁)

​	本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫递归锁，指的是同一线程，在外层函数获得锁之后，内存递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是可重入锁。

#### 4.1.9.9. 公平锁和非公平锁

**公平锁 (Fair)**

​	加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

**非公平锁 (Nonfair)**

​	加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到对位等待

1. 非公平锁性能别公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列。
2. Java 中 synchronized 是非公平锁，ReentrantLock 默认的 lock() 方法采用的是非公平锁。

#### 4.1.9.10.  ReadWriteLock 读写锁

​	为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁和写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。

**读锁**

​	如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上写锁。

**写锁**

​	如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁。

​	Java 中读写锁有个接口 java.util.concurrent.locks.ReadWriteLock， 也有具体的实现 ReentrantReadWriteLock。

#### 4.1.9.11.  共享锁和独占锁

​	java 并发包提供的加锁模式分为独占锁和共享锁。

**独占锁**

​	独占锁模式下，每次只能由一个线程持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取到锁，则其他读线程都只能等到，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。

**共享锁**

​	共享锁则允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。

1. AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。
2. java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但不能两者同时进行。

#### 4.1.9.12. 重量级锁 (Mutex Lock)

​	Synchronized 是通过对象内部的一个叫做监视器锁 (monitor) 来实现的。但是监视器锁本质又是依赖底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高。因此，这种依赖操作系统 Mutex Lock 所实现的锁我们称之为 "重量级锁" 。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK 1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了 "轻量级锁" 和 "偏向锁" 。

#### 4.1.9.13. 轻量级锁

​	锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。

**锁升级**

​	随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁 (但是锁的升级是单向的，也就是说只能从低到高级，不会出现锁的降级)。

​	"轻量级" 是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

#### 4.1.9.14 偏向锁

​	Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入 (CAS) 的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况小尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadId 的时候依赖一次 CAS 原子指令 (由于一旦出现多线程竞争的情况就必须撤销偏向锁，所有偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗) 。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。

#### 4.1.9.15.  分段锁

​	分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践。

#### 4.1.9.16. 锁优化

**减少锁持有时间**

​	只用在有线程安全要求的程序上加锁

**减小锁粒度**

​	将大对象 (这个对象可能会被很多线程访问) ，拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最典型的减小锁粒度案例就是 ConcurrentHashMap。

**锁分离**

​	最常见的锁分离就是读写分离 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK并发包。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据。

**锁粗化**

​	通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡是都有一个度，如果对一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能优化。

**锁消除**

​	锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。

### 4.1.10. 线程基本方法

​	线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield等。









#### 4.1.10.1. 线程等待 (wait)

​	调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或中断才会返回，需要注意的是调用 wait() 方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。

#### 4.1.10.2. 线程睡眠 (sleep)

​	sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁，sleep(long) 会导致线程进入 TIME-WATING 状态，而 wait() 方法会导致当前线程进入 WAITING 状态

#### 4.1.10.3. 线程让步 (yield)

​	yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。

#### 4.1.10.4. 线程中断 (interrupt)

​	中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞、终止等)。

1. 调用 interrupt() 方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。
2. 若调用 sleep() 而是线程处于 TIME-WATING 状态，这时调用 interrupt() 方法，会抛出 InterruptedException ，从而是线程提前结束 TIMED-WAITING 状态。
3. 许多生命抛出 InterruptedException 的方法 (如 Thread.sleep(long mills)方法)，抛出异常前，都会清除中断标识位，所以保存异常后，调用 isInterrupted() 方法将会返回 false。
4. 中断状态时线程固有的一个标识位，可以通过此标识位安全的终止线程。比如，你想终止一个线程 thread 的时候，可以调用 thread.interrupt() 方法，在线程的 run 方法内部可以根据 thread.isInterrupted() 的值来优雅的终止线程。

#### 4.1.10.5. Join 等待其他线程终止

​	join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再有阻塞状态变为就绪状态，等待 cpu 的宠幸。

#### 4.1.10.6. 为什么要用 join() 方法

​	很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程要在子线程结束后再结束，这时就要用到 join() 方法。

```java
System.out.println(Thread.currentThread().getName() + "线程运行开始！");
Thead6 thread1 = new Thread6();
thread1.setName("线程B");
thread1.join();
System.out.println("这时thread1执行完毕之后才能执行主线程");
```

#### 4.1.10.7. 线程唤醒 (notify)

​	Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程对象都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现作出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll()，唤醒再次监视器上等待的所有线程。

#### 4.1.10.8. 其他方法：

1. sleep()：强迫一线线程睡眠 N 毫秒。
2. isAlive()：判断一个线程释放存活。
3. join()：等待线程终止。
4. activeCount()：程序中活跃的线程数。
5. enumerate()：得到程序中的线程。
6. currentThread()：得到当前线程。
7. isDaemon()：一个线程是否为守护线程。
8. setDaemon()：设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)。
9. setName()：为线程设置一个名称。
10. wait()：强迫一个线程等待。
11. notify()：通知一个线程继续运行。
12. setPriority()：设置一个线程的优先级。
13. getPriority()：获得一个线程的优先级。

### 4.1.11. 线程上下文切换

​	巧妙地利用了时间片轮转的方式，CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务状态后，继续服务下一任务，任务的状态保存及再加载，这段过程就叫做上下文切换。时间片轮转的方式使得多个任务在同一颗 CPU 上执行变成了可能。





#### 4.1.11.1.  进程

​	(有时候也称作做任务) 是指一个程序运行的示例。在 Linux 系统中，线程就是能并行运行且与他们的父进程 (创建他们的线程) 共享同一地址空间 (一段内存区域) 和其他资源的轻量级的进程。

#### 4.1.11.2. 上下文

​	是指某一时间点 CPU 寄存器和程序计数器的内容。

#### 4.1.11.3. 寄存器

​	是 CPU 内部的数量较少但是速度很快的内存 (与之对应的是 CPU 外部相对较慢的 RAM 主内存 )。寄存器通过对常用值 (通常是运算的中间值) 的快速访问来提高计算机程序运行的速度。

#### 4.1.11.4. 程序计数器

​	是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要执行的指令的位置，具体依赖于特定的系统。

#### 4.1.11.5. PCB-"切换帧"

​	上下文切换可以认为是内核 (操作系统的核心) 在 CPU 上对于进程 (包括线程) 进行切换，上下文切换过程中的信息是保存在进程控制块 (PCB，process control block) 中的。PCB 还经常被称作 "切换帧" (switchframe)。信息会一直保存到 CPU 的内存中，直到他们被再次使用。

#### 4.1.11.6. 上下文切换的活动：

1. 挂起一个进程，将这个进程在 CPU 中的状态 (上下文) 存储于内存中的某处。
2. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。
3. 跳转到程序计数器锁指向的位置 (即跳转到进程被中断的代码行)，以恢复该进程在程序中。

#### 4.1.11.7. 引起上下文切换的原因

1. 当前指向任务的时间片用完之后，系统 CPU 正常调度下一个任务；
2. 当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；
3. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；
4. 用户代码挂起当前任务，让出 CPU 时间；
5. 硬件中断；

### 4.1.12  同步锁与死锁

#### 4.1.12.1. 同步锁

​	当多个线程同时访问一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。

#### 4.1.12.2. 死锁

​	何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。

### 4.1.13. 线程池原理

​	线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发；管理线程。

#### 4.1.13.1. 线程复用

​	每一个 Thread 的类都有一个 start 方法。当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。这就是线程池的实现原理。循环方法中不断取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。

#### 4.1.13.1. 线程池的组成

​	一般的线程池主要分为以下4个组成部分：

1. 线程池管理器：用于创建并管理线程池

2. 工作线程：线程池中的线程

3. 任务接口：每个任务必须实现的接口，用于工作线程调度器运行

4. 任务队列：用于存放待处理的任务，提供一种缓存机制

   Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor，Callable 和 Future、FutureTask 这几个类。





ThreadPoolExecutor 的构造方法如下：

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue){
  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}
```

1. corePoolSize: 指定了线程池中的线程数量。
2. maximumPoolSize: 指定了线程池中最大线程数量。
3. keepAliveTime: 当前线程池超过 corePoolSize 时，多余空闲线程存活时间，即多少时间内会被销毁。
4. unit: keepAliveTime 的单位。
5. workQueue: 任务队列，被提交但尚未执行的任务。
6. threadFactory: 线程工厂，用于创建线程，一般用默认的即可。
7. handler: 拒绝策略，当任务太多来不及处理，如何拒绝任务。

#### 4.1.12.3.  拒绝策略

​	线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。

JDK 内置的拒绝策略如下：

1. AbortPolicy: 直接抛出异常，阻止系统正常运行。
2. CallerRunsPolicy: 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是任务提交线程的性能极有可能会急剧下降。
3. DiscardOldestPolicy: 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。
4. DiscardPolicy: 该策略默默地丢弃无法处理的任务，不予任务处理。如果允许任务丢失，这是最好的一种方案。

以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。

#### 4.1.13.4. Java 线程池工作过程

1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。

2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断：

   a）如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；

   b）如果正在运行的线程数量大于 corePoolSize，那么将这个任务放入队列；

   c）如果这时候队列满了，而且在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；

   d）如果队列满了，而且运行的线程数大于或等于 maximumPoolSize，那么线程池会抛出 RejectExecutionException。

3. 但一个线程完成任务是，它会从队列中取下一个任务来执行。

4. 当一个线程无事可做，超过一定时间 (keepAliveTime) 时，线程池会判断，如果当前运行的线程数大于 corePooleSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。













### 4.1.14.  Java 阻塞队列原理

阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：

1. 当队列中没有数据的情况下，消费者端的所有线程都会自动阻塞 (挂起)，直到有数据放入队列。



2.  当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞 (挂起)，直到队列中有空的位置，线程被自动唤醒。





#### 4.1.14.1. 阻塞队列的主要方法

| 方法类型 | 抛出异常  | 特殊值   | 阻塞   | 超时               |
| -------- | --------- | -------- | ------ | ------------------ |
| 插入     | add(e)    | offer(e) | put(e) | offer(e,time,unit) |
| 移除     | remove()  | poll()   | take() | poll(time,unit)    |
| 检查     | element() | peek()   | 不可用 | 不可用             |

* **抛出异常：抛出一个异常**
* **特殊值：返回一个特殊值 (null 或 false，视情况而定)**
* **阻塞：在成功操作之前，一直阻塞线程**
* **超时：放弃前只在最大的时间内阻塞**

**插入操作：**

1. public abstract boolean add(E e): 将制定元素插入此队列中 (如果立即可行且不会违反容量限制) ，成功返回 true，如果当前没有可用空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。

2. public abstract boolean offer(E e): 将指定元素插入队列中 (如果立即可行且不会违反容量限制)，成功时返回 true，如果当前没有可用的空间，则返回 false。

3. public abstract void put(E e) throws InterruptedException：将指定元素插入此队列中，将等待可用的空间(如果有必要)

   ```java
   public void put(E paramE) throws InterruptedException{
     checkNotNull(paramE);
     ReentrantLock localReentrantLock = this.lock;
     localReentrantLock.lockInterruptibly();
     try {
       while (this.count == this.items.length){
         this.notFull.await(); // 如果队列满了，则线程阻塞等待
       }
       enqueue(paramE);
     	localReentrantLock.unlock();
     }finally {
       localReentrantLock.unlock();
     }
   }
   ```

   

4. offer(E o, long timeout, TimeUnit unit):可以设定等待时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。

**获取数据操作：**

1. poll(long time): 取走 BlockingQueue 里排在首位的对象，若不能立即取出来，则可以等 time 参数规定的时间，取不到时返回 null；
2. poll(long timeout, TimeUnit unit): 从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。
3. take(): 取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，阻断进入等待状态直到 BlockingQueue 有新的数据被加入。
4. drainTo()： 一次性从 BlockingQueue 获取所有可用的数据对象 (还可以指定获取数据的个数)，通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。

#### 4.1.14.2. Java 中的阻塞队列

1. ArrayBlockingQueue ： 由数组结构组成的有界阻塞队列。
2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。
3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。
4. DelayQueue：使用优先级队列实现的无界阻塞队列。
5. SynchronousQueue ：不存储元素的阻塞队列。
6. LinkedTransferQueue ： 由链表结构组成的无界阻塞队列。
7. LinkedBlockingDeque ：由链表结构组成的双向阻塞队列。